# Generate a l1ode-object with element "truth"

# The system is generated by following steps:

# 1. Generating a block-diagonal matrix,
# as the linear term of the system.
# Each block is a scalar "a",
# indicating a real eigen-value,
# or of form:
#     a b
#    -b a
# which indicates a pair of complex eigen-values: a+-bi
# The analytic solution is:
#     exp(at)
# for real eigen-value, and
#     exp(at)sin(bt)
#     exp(at)cos(bt)
# for a pair of complex eigen-values.
# Each "a" is generated independently and uniform-randomly in range:
#     [real_min,real_max].
# The negative "real_min" value satisfies that the magnitude at the last
# time point is approximately half of that at the first one.
# "real_max" is half of the lower-bound.
# Each "b" should be bounded away from each other
# to decrease correlation of the system.
# Currently they are chosen as an arithmetic sequence.
# The smallest "b" is chosen to contain approximately
# one period in the time span when no real eigen-value exists,
# and double that value when there exists one real eigen-value.
# The order of "b" is permuted to breaking the ascension.


generation.l1ode <- function (
  dimension
  , timepoint
  , sanitycheck = FALSE
)

# INPUT:
# dimension: Dimension of the system.
#   Currently the system can contain complex eigen-values,
#   which appear in pairs,
#   and at most one real eigen-value,
#   since currently we have not found a good way to control
#   the correlation between curves of real eigen-values.
#   Hence if "dimension" is even, all eigen-values are complex,
#   otherwise there exists one real eigen-value in the spectrum.
# timepoint: Time points for observation data curves.
# sanitycheck: Whether to perform a sanity check on input arguments.

# OUTPUT:
# A l1ode-object containing element "truth",
#   which contains following elements:
# initial: Initial condition of the system.
# linear: Linear term of the system.
#   It will be identical to the first column of "curve".
# eigen_complex: Complex eigenvalues of the linear term.
#   Notice that the conjugate of each element is also an eigenvalue.
# eigen_real: Real eigenvalues of the linear term.
# data: Data matrix for value at given time points.
#   Each column stands for a curve.
#   First column is "timepoint".

{

ret <- list()
class(ret) <- 'l1ode'

# Sanity check#{{{
if ( sanitycheck )
{
  # dimension#{{{
  if (
    !is.integer(dimension)
    || length(dimension)!=1
    || dimension<=0
  )
  {
    stop('Argument "dimension" must be a positive integer.')
  }
  #}}}

  # timepoint#{{{
  if (
    !is.numeric(timepoint)
    || length(timepoint)<2
    || is.unsorted(timepoint,strictly=TRUE)
  )
  {
    stop('Argument "timepoint" must be a numeric vector ' ,
      'with strictly ascending elements.')
  }
  #}}}
}
#}}}

# Generate eigenvalues#{{{
num_real_eigen <- dimension%%2
num_complex_eigen <- floor(dimension/2)

time_span <- tail(timepoint,1) - timepoint[1]

real_min = -0.7/time_span
real_max = real_min/2

eigen_real <- runif (
  num_complex_eigen + num_real_eigen
  , real_min
  , real_max
)

eigen_imaginary <- 1:num_complex_eigen
if ( num_real_eigen>0 )
{
  eigen_imaginary <- eigen_imaginary + 1
}
eigen_imaginary <- eigen_imaginary * 2 * pi / time_span

require('permute')
permute_index <- permute::shuffle(dimension/2)
eigen_imaginary <- eigen_imaginary[permute_index]

ret$truth$eigen_complex <-
  1i*eigen_imaginary + eigen_real[1:num_complex_eigen]
if ( num_real_eigen==1 )
{
  ret$truth$eigen_real <- tail(eigen_real,1)
}
else
{
  ret$truth$eigen_real <- numeric(0)
}
#}}}

# Linear term#{{{
temp <- (1:num_complex_eigen) * 2

ret$truth$linear <- matrix ( 0 , dimension , dimension )

ret$truth$linear [ cbind(temp,temp) ] <-
  eigen_real[1:num_complex_eigen]
ret$truth$linear [ cbind(temp-1,temp-1) ] <-
  eigen_real[1:num_complex_eigen]
ret$truth$linear [ cbind(temp-1,temp) ] <-
  eigen_imaginary
ret$truth$linear [ cbind(temp,temp-1) ] <-
  -eigen_imaginary
#}}}

# Data#{{{
ret$truth$data <- matrix ( 0 , length(timepoint) , dimension )

lapply ( 1 : num_complex_eigen ,
  function(index)
  {
    temp <- exp ( eigen_real[index] * timepoint )
    ret$truth$data[,2*index-1] <<-
      temp * sin ( eigen_imaginary[index] * timepoint )
    ret$truth$data[,2*index] <<-
      temp * cos ( eigen_imaginary[index] * timepoint )
    return()
  }
)
#}}}

# Real eigenvalue#{{{
if ( num_real_eigen == 1 )
{
  ret$truth$linear[dimension,dimension] <- tail(eigen_real,1)
  ret$truth$data[,dimension] <- exp ( tail(eigen_real,1) * timepoint )
}
#}}}

# Initial condition#{{{
ret$truth$initial <- rep ( 1 , dimension )
ret$truth$initial [ 2*(1:num_complex_eigen)-1 ] <- 0
#}}}

# Return#{{{
ret$truth$data <- cbind ( timepoint , ret$truth$data )

return(ret)
#}}}

}
